#!/bin/sh
#
# @license http://www.gnu.org/licenses/gpl.html GPL Version 3
# @author David Hönel <davidh1990@gmx.de>
# @copyright Copyright (c) 2015 David Hönel
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

# Include Configuration File
CONFIG_FILE="config.sh"
if [ -f ${CONFIG_FILE}; then
. ${CONFIG_FILE}
else
	echo "Aborted, no configuration file found!"
	exit 1
fi

postProcessTV () {
	cd ${1}

	filebot -rename "${1}" ${filebotTVDB} --format "${2}/${filebotTVFolder}/${filebotTVFile}" ${filebotTVLanguage} ${filebotTVRecursive} ${filebotTVNonstrict}

	if [ ${enableFilebotCleaner} = true ]; then
		filebot -script fn:cleaner "${1}"
	fi
}

postProcessMovies () {
	cd ${1}

	if [ ${useStereoFilter} = true ];  then
		cat /dev/null > ${stereoFilterMatchedFiles}

		for f in *
		do
			ls "${f}" | grep mkv | mediainfo -f "${f}" | grep "2 channels" && echo "${f}" >> "${stereoFilterMatchedFiles}"
		done

		if [ -s ${stereoFilterMatchedFiles} ]
			while read p; do
				mv ${p} ${stereoFilterTempFolder}
			done < "${stereoFilterMatchedFiles}"
		else
			:
		fi

		if [ ls -A ${stereoFilterTempFolder} ]; then
			filebot -rename "${stereoFilterTempFolder}" ${filebotMoviesDB} "${filebotMoviesFormatStereo}" ${filebotMoviesLanguage} ${filebotMoviesRecursive} ${filebotMoviesNonstrict}

			if [ ${enableFilebotCleaner} = true ]; then
				filebot -script fn:cleaner "${stereoFilterTempFolder}"
			fi
		else
			echo "No File in "${stereoFilterTempFolder}", nothing to do here."
		fi
	fi

	filebot -rename "${1}" ${filebotMoviesDB} --format "${2}/${filebotMoviesFolder}/${filebotMoviesFile}" ${filebotMoviesLanguage} ${filebotMoviesRecursive} ${filebotMoviesNonstrict}

	if [ ${enableFilebotCleaner} = true ]; then
		filebot -script fn:cleaner "${stereoFilterTempFolder}"
	fi

	if [ ${enableRemoteSyncInPostProcessingMovies} = true ]; then
		postprocessing SyncMovies
	fi
}

checkLocalMountPath () {
	if [ ! -d ${1} ]; then
		echo "Local Mount Path ${1} does not exist. Trying to create..."
		mkdir -p ${1}
			if [ $? -eq 0 ]; then
				echo "Local Mount Path ${1} created successfully."
			else
				echo "Could not create Local Mount Path ${1}. Aborting..."
				exit 1
			fi
	fi
}

mountRemoteSyncPath () {
	echo "Checking if ${1} is already mounted."
	if [ `stat -fc%t:%T "${1}"` != `stat -fc%t:%T "${1}/.."` ] && [ -e ${1}/${2}.check ]; then
		echo "${1} is already mounted."
	else
		echo "${1} is not mounted."
		echo "Mounting Directory now...."
		mount ${1}
		if [ $? -eq 0 ] && [ -e ${1}/${2}.check ]; then
			echo "${1} mounted successfully."
		else
			echo "${1} could not be mounted! Aborting..."
			echo "Maybe ${2}.check in ${1} is missing?"
			exit 1
		fi
	fi
}

umountRemoteSyncPath () {
	umount ${1}
	if [ $? -eq 0 ]; then
			echo "${1} unmounted successfully."
		else
			echo "${1} could not be unmounted!"
	fi	
}

collectFiles () {
	if [ $1 = TV ]; then 
		downloadPath = ${downloadPathTV}
		remoteSyncAge = ${remoteSyncAgeTV}
		excludeList = ${excludeListTV}
		useExcludeList = ${useExcludeListTV}
	elif [ $1 = Movies ]; then
		downloadPath = ${downloadPathMovies}
		remoteSyncAge = ${remoteSyncAgeMovies}
		excludeList = ${excludeListMovies}
		useExcludeList = ${useExcludeListMovies}
	else
		echo "Called with unknown argument. Aborting..."
		exit 1
	fi

	cd ${downloadPath}

	if [ $? -eq 1 ]; then
		echo "Error, could not change directory to ${downloadPath}"
		exit 1
	elif [ ${useExcludeList} = true ]; then
		find . -type f ${remoteSyncAge} | sed -f ${excludeList} > ${filesForRemoteSync}
	else
		find . -type f ${remoteSyncAge} > ${filesForRemoteSync}
	fi
}

collectFilesSeason () {
	echo "Writing Season with correct path to ${filesForRemoteSync}"
	
	cd ${destinationPathTV}
	
	if [ $? -eq 1 ]; then
		echo "Error, could not change directory to ${destinationPathTV}"
		exit 1
	fi

	if [ -n ${3} ]
		find . -type f -name "${1}*${2}*" -mtime "${3}" | tee ${filesForRemoteSync}
	else
		find . -type f -name "${1}*${2}*" | tee ${filesForRemoteSync}
	fi
}

syncFiles () {

	destinationPath = ${1}
	
	if [ ${2} = dryrun ]; then
		echo "Syncing files now...(dryrun)"
		rsync -Ranvh --files-from=${filesForRemoteSync} . ${destinationPath}
	else
		echo "Syncing files now..."
		rsync -Ravh --files-from=${filesForRemoteSync} . ${destinationPath}
		if [ $? -eq 1 ]; then
			echo "Files synced successfully."
		else
			echo "Filetransfer ended with errors!"
		fi
	fi
}

syncFilesSeason () {
	if [ ${3} = dryrun ] || [ ${4} = dryrun ]
		echo "Syncing season now... Dryrun!"
		rsync -Ravhn --files-from=${filesForRemoteSync} . ${destinationPathTV}
	else
		echo "Syncing Season now..."
		rsync -Ravh --files-from=${filesForRemoteSync} . ${destinationPathTV}
		if [ $? -eq 1 ]; then
			echo "Files synced successfully."
		else
			echo "Filetransfer ended with errors!"
		fi
	fi
}

updateXBMCLib () {
	if [ ${useKodiLibraryUpdate} = true ]; then
		xbmc-send --action="UpdateLibrary(video)" --host=${kodiHost}
		echo "Updating Kodi Library..."
	elif [ ${useKodiLibraryUpdate} = clean ]; then
		echo "Cleaning Kodi Library..."
		xbmc-send --action="CleanLibrary(video)" --host=${kodiHost}
		echo "Waiting ${kodiCleanWaitTime} seconds before Updating Kodi Library."
		sleep ${kodiCleanWaitTime}
		xbmc-send --action="UpdateLibrary(video)" --host=${kodiHost}
		echo "Updating Kodi Library..."
	else
		:
	fi
}

case $1 in
	SyncTV)
		if [ $2 = dryrun ]; then
			collectFiles TV dryrun
		else
			checkLocalMountPath ${localSyncPathTV}
			mountRemoteSyncPath ${remoteSyncPathTV} TV
			collectFiles TV
			syncFiles TV
			updateXBMCLib
			umountRemoteSyncPath ${localSyncPathTV}
		fi
	;;
	
	SyncMovies)
		if [ $2 = dryrun ]; then
			collectFiles Movies dryrun
		else
			checkLocalMountPath ${localSyncPathMovies}
			mountRemoteSyncPath ${remoteSyncPathMovies} Movies
			collectFiles Movies
			syncFiles Movies
			updateXBMCLib
			umountRemoteSyncPath ${localSyncPathMovies}
		fi
	;;

	SyncSeason)
		checkLocalMountPath ${localSyncPathTV}
		mountRemoteSyncPath ${remoteSyncPathTV}
		collectFilesSeason ${2} ${3} ${4} ${5}
	;;	

	postProcessTVNative)
		postProcessTV "${downloadPathTVNative}" "${destinationPathTVNative}"
	;;

	postProcessTVSecond)
		postProcessTV "${downloadPathTVEN}" "${destinationPathTVEN}"

	postProcessMoviesNative)
		postProcessMovies "${downloadPathMoviesNative}" "${downloadPathMoviesNative}"
	;;

	postProcessMoviesSecond)
		postProcessMovies "${downloadPathMoviesEN}" "${downloadPathMoviesEN}"
	 *)
		echo "PostProcessing called with unknown argument."
		readme
		exit 1
	;;
esac

exit 0